{"version":3,"file":"aframe-extras.misc.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;AACA;AACA,aAAa,UAAU,iBAAiB;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,sBAAsB,+CAA+C;AACrE,uBAAuB,kDAAkD;AACzE,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;AC/BD;AACA,YAAY,sCAAsC;AAClD,YAAY;AACZ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,gBAAgB,sCAAsC;AACtD,uBAAuB,eAAe;AACtC,mBAAmB,2BAA2B;AAC9C,gBAAgB;AAChB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;ACpID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD,iCAAiC,mBAAmB;AACpD,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACzED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;;;;;;;;;ACtBD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,eAAe,YAAY;AAC3B,cAAc,YAAY;AAC1B,YAAY,oBAAoB;AAChC,aAAa,cAAc;AAC3B,YAAY;AACZ,GAAG;AACH;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,mBAAmB,OAAO;AAC5C;;;;;;;UChKA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA,mBAAO,CAAC,8CAAc;AACtB,mBAAO,CAAC,kDAAgB;AACxB,mBAAO,CAAC,kCAAQ;AAChB,mBAAO,CAAC,wDAAmB;AAC3B,mBAAO,CAAC,wDAAmB","sources":["webpack://bs-aframe-extras/webpack/universalModuleDefinition","webpack://bs-aframe-extras/./src/misc/checkpoint.js","webpack://bs-aframe-extras/./src/misc/cube-env-map.js","webpack://bs-aframe-extras/./src/misc/grab.js","webpack://bs-aframe-extras/./src/misc/normal-material.js","webpack://bs-aframe-extras/./src/misc/sphere-collider.js","webpack://bs-aframe-extras/webpack/bootstrap","webpack://bs-aframe-extras/./src/misc/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","module.exports = AFRAME.registerComponent('checkpoint', {\r\n  schema: {\r\n    offset: {default: {x: 0, y: 0, z: 0}, type: 'vec3'}\r\n  },\r\n\r\n  init: function () {\r\n    this.active = false;\r\n    this.targetEl = null;\r\n    this.fire = this.fire.bind(this);\r\n    this.offset = new THREE.Vector3();\r\n  },\r\n\r\n  update: function () {\r\n    this.offset.copy(this.data.offset);\r\n  },\r\n\r\n  play: function () { this.el.addEventListener('click', this.fire); },\r\n  pause: function () { this.el.removeEventListener('click', this.fire); },\r\n  remove: function () { this.pause(); },\r\n\r\n  fire: function () {\r\n    const targetEl = this.el.sceneEl.querySelector('[checkpoint-controls]');\r\n    if (!targetEl) {\r\n      throw new Error('No `checkpoint-controls` component found.');\r\n    }\r\n    targetEl.components['checkpoint-controls'].setCheckpoint(this.el);\r\n  },\r\n\r\n  getOffset: function () {\r\n    return this.offset.copy(this.data.offset);\r\n  }\r\n});\r\n","/**\r\n * @param  {Array<THREE.Material>|THREE.Material} material\r\n * @return {Array<THREE.Material>}\r\n */\r\nfunction ensureMaterialArray (material) {\r\n  if (!material) {\r\n    return [];\r\n  } else if (Array.isArray(material)) {\r\n    return material;\r\n  } else if (material.materials) {\r\n    return material.materials;\r\n  } else {\r\n    return [material];\r\n  }\r\n}\r\n\r\n/**\r\n * @param  {THREE.Object3D} mesh\r\n * @param  {Array<string>} materialNames\r\n * @param  {THREE.Texture} envMap\r\n * @param  {number} reflectivity  [description]\r\n */\r\nfunction applyEnvMap (mesh, materialNames, envMap, reflectivity) {\r\n  if (!mesh) return;\r\n\r\n  materialNames = materialNames || [];\r\n\r\n  mesh.traverse((node) => {\r\n\r\n    if (!node.isMesh) return;\r\n\r\n    const meshMaterials = ensureMaterialArray(node.material);\r\n\r\n    meshMaterials.forEach((material) => {\r\n\r\n      if (material && !('envMap' in material)) return;\r\n      if (materialNames.length && materialNames.indexOf(material.name) === -1) return;\r\n\r\n      material.envMap = envMap;\r\n      material.reflectivity = reflectivity;\r\n      material.needsUpdate = true;\r\n\r\n    });\r\n\r\n  });\r\n}\r\n\r\n/**\r\n * Specifies an envMap on an entity, without replacing any existing material\r\n * properties.\r\n */\r\nmodule.exports = AFRAME.registerComponent('cube-env-map', {\r\n  multiple: true,\r\n\r\n  schema: {\r\n    path: {default: ''},\r\n    extension: {default: 'jpg', oneOf: ['jpg', 'png']},\r\n    enableBackground: {default: false},\r\n    reflectivity: {default: 1, min: 0, max: 1},\r\n    materials: {default: []}\r\n  },\r\n\r\n  init: function () {\r\n    const data = this.data;\r\n\r\n    this.texture = new THREE.CubeTextureLoader().load([\r\n      data.path + 'posx.' + data.extension, data.path + 'negx.' + data.extension,\r\n      data.path + 'posy.' + data.extension, data.path + 'negy.' + data.extension,\r\n      data.path + 'posz.' + data.extension, data.path + 'negz.' + data.extension\r\n    ]);\r\n    this.texture.format = THREE.RGBAFormat;\r\n\r\n    this.object3dsetHandler = () => {\r\n      const mesh = this.el.getObject3D('mesh');\r\n      const data = this.data;\r\n      applyEnvMap(mesh, data.materials, this.texture, data.reflectivity);\r\n    };\r\n\r\n    this.object3dsetHandler();\r\n    this.el.addEventListener('object3dset', this.object3dsetHandler);\r\n    \r\n  },\r\n\r\n  update: function (oldData) {\r\n    const data = this.data;\r\n    const mesh = this.el.getObject3D('mesh');\r\n\r\n    let addedMaterialNames = [];\r\n    let removedMaterialNames = [];\r\n\r\n    if (data.materials.length) {\r\n      if (oldData.materials) {\r\n        addedMaterialNames = data.materials.filter((name) => !oldData.materials.includes(name));\r\n        removedMaterialNames = oldData.materials.filter((name) => !data.materials.includes(name));\r\n      } else {\r\n        addedMaterialNames = data.materials;\r\n      }\r\n    }\r\n    if (addedMaterialNames.length) {\r\n      applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);\r\n    }\r\n    if (removedMaterialNames.length) {\r\n      applyEnvMap(mesh, removedMaterialNames, null, 1);\r\n    }\r\n\r\n    if (oldData.materials && data.reflectivity !== oldData.reflectivity) {\r\n      const maintainedMaterialNames = data.materials\r\n        .filter((name) => oldData.materials.includes(name));\r\n      if (maintainedMaterialNames.length) {\r\n        applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);\r\n      }\r\n    }\r\n\r\n    if (this.data.enableBackground && !oldData.enableBackground) {\r\n      this.setBackground(this.texture);\r\n    } else if (!this.data.enableBackground && oldData.enableBackground) {\r\n      this.setBackground(null);\r\n    }\r\n  },\r\n\r\n  remove: function () {\r\n    this.el.removeEventListener('object3dset', this.object3dsetHandler);\r\n    const mesh = this.el.getObject3D('mesh');\r\n    const data = this.data;\r\n\r\n    applyEnvMap(mesh, data.materials, null, 1);\r\n    if (data.enableBackground) this.setBackground(null);\r\n  },\r\n\r\n  setBackground: function (texture) {\r\n    this.el.sceneEl.object3D.background = texture;\r\n  }\r\n});","/* global CANNON */\r\n\r\n/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Handles events coming from the hand-controls.\r\n * Determines if the entity is grabbed or released.\r\n * Updates its position to move along the controller.\r\n */\r\nmodule.exports = AFRAME.registerComponent('grab', {\r\n  init: function () {\r\n    this.system = this.el.sceneEl.systems.physics;\r\n\r\n    this.GRABBED_STATE = 'grabbed';\r\n\r\n    this.grabbing = false;\r\n    this.hitEl =      /** @type {AFRAME.Element}    */ null;\r\n    this.physics =    /** @type {AFRAME.System}     */ this.el.sceneEl.systems.physics;\r\n    this.constraint = /** @type {CANNON.Constraint} */ null;\r\n\r\n    // Bind event handlers\r\n    this.onHit = this.onHit.bind(this);\r\n    this.onGripOpen = this.onGripOpen.bind(this);\r\n    this.onGripClose = this.onGripClose.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const el = this.el;\r\n    el.addEventListener('hit', this.onHit);\r\n    el.addEventListener('gripdown', this.onGripClose);\r\n    el.addEventListener('gripup', this.onGripOpen);\r\n    el.addEventListener('trackpaddown', this.onGripClose);\r\n    el.addEventListener('trackpadup', this.onGripOpen);\r\n    el.addEventListener('triggerdown', this.onGripClose);\r\n    el.addEventListener('triggerup', this.onGripOpen);\r\n  },\r\n\r\n  pause: function () {\r\n    const el = this.el;\r\n    el.removeEventListener('hit', this.onHit);\r\n    el.removeEventListener('gripdown', this.onGripClose);\r\n    el.removeEventListener('gripup', this.onGripOpen);\r\n    el.removeEventListener('trackpaddown', this.onGripClose);\r\n    el.removeEventListener('trackpadup', this.onGripOpen);\r\n    el.removeEventListener('triggerdown', this.onGripClose);\r\n    el.removeEventListener('triggerup', this.onGripOpen);\r\n  },\r\n\r\n  onGripClose: function () {\r\n    this.grabbing = true;\r\n  },\r\n\r\n  onGripOpen: function () {\r\n    const hitEl = this.hitEl;\r\n    this.grabbing = false;\r\n    if (!hitEl) { return; }\r\n    hitEl.removeState(this.GRABBED_STATE);\r\n    this.hitEl = undefined;\r\n    this.system.removeConstraint(this.constraint);\r\n    this.constraint = null;\r\n  },\r\n\r\n  onHit: function (evt) {\r\n    const hitEl = evt.detail.el;\r\n    // If the element is already grabbed (it could be grabbed by another controller).\r\n    // If the hand is not grabbing the element does not stick.\r\n    // If we're already grabbing something you can't grab again.\r\n    if (hitEl.is(this.GRABBED_STATE) || !this.grabbing || this.hitEl) { return; }\r\n    hitEl.addState(this.GRABBED_STATE);\r\n    this.hitEl = hitEl;\r\n    this.constraint = new CANNON.LockConstraint(this.el.body, hitEl.body);\r\n    this.system.addConstraint(this.constraint);\r\n  }\r\n});\r\n","/**\r\n * Recursively applies a MeshNormalMaterial to the entity, such that\r\n * face colors are determined by their orientation. Helpful for\r\n * debugging geometry\r\n */\r\nmodule.exports = AFRAME.registerComponent('normal-material', {\r\n  init: function () {\r\n    this.material = new THREE.MeshNormalMaterial({flatShading: true});\r\n    this.applyMaterial = this.applyMaterial.bind(this);\r\n    this.el.addEventListener('object3dset', this.applyMaterial);\r\n    this.applyMaterial();\r\n  },\r\n\r\n  remove: function () {\r\n    this.el.removeEventListener('object3dset', this.applyMaterial);\r\n  },\r\n\r\n  applyMaterial: function () {\r\n    this.el.object3D.traverse((node) => {\r\n      if (node.isMesh) node.material = this.material;\r\n    });\r\n  }\r\n});\r\n","/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Implement bounding sphere collision detection for entities with a mesh.\r\n * Sets the specified state on the intersected entities.\r\n *\r\n * @property {string} objects - Selector of the entities to test for collision.\r\n * @property {string} state - State to set on collided entities.\r\n *\r\n */\r\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\r\n  schema: {\r\n    enabled: {default: true},\r\n    interval: {default: 80},\r\n    objects: {default: ''},\r\n    state: {default: 'collided'},\r\n    radius: {default: 0.05},\r\n    watch: {default: true}\r\n  },\r\n\r\n  init: function () {\r\n    /** @type {MutationObserver} */\r\n    this.observer = null;\r\n    /** @type {Array<Element>} Elements to watch for collisions. */\r\n    this.els = [];\r\n    /** @type {Array<Element>} Elements currently in collision state. */\r\n    this.collisions = [];\r\n    this.prevCheckTime = undefined;\r\n\r\n    this.eventDetail = {};\r\n    this.handleHit = this.handleHit.bind(this);\r\n    this.handleHitEnd = this.handleHitEnd.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const sceneEl = this.el.sceneEl;\r\n\r\n    if (this.data.watch) {\r\n      this.observer = new MutationObserver(this.update.bind(this, null));\r\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\r\n    }\r\n  },\r\n\r\n  pause: function () {\r\n    if (this.observer) {\r\n      this.observer.disconnect();\r\n      this.observer = null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update list of entities to test for collision.\r\n   */\r\n  update: function () {\r\n    const data = this.data;\r\n    let objectEls;\r\n\r\n    // Push entities into list of els to intersect.\r\n    if (data.objects) {\r\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\r\n    } else {\r\n      // If objects not defined, intersect with everything.\r\n      objectEls = this.el.sceneEl.children;\r\n    }\r\n    // Convert from NodeList to Array\r\n    this.els = Array.prototype.slice.call(objectEls);\r\n  },\r\n\r\n  tick: (function () {\r\n    const position = new THREE.Vector3(),\r\n        meshPosition = new THREE.Vector3(),\r\n        colliderScale = new THREE.Vector3(),\r\n        size = new THREE.Vector3(),\r\n        box = new THREE.Box3(),\r\n        collisions = [],\r\n        distanceMap = new Map();\r\n    return function (time) {\r\n      if (!this.data.enabled) { return; }\r\n\r\n      // Only check for intersection if interval time has passed.\r\n      const prevCheckTime = this.prevCheckTime;\r\n      if (prevCheckTime && (time - prevCheckTime < this.data.interval)) { return; }\r\n      // Update check time.\r\n      this.prevCheckTime = time;\r\n\r\n      const el = this.el,\r\n          data = this.data,\r\n          mesh = el.getObject3D('mesh');\r\n      let colliderRadius;\r\n\r\n      if (!mesh) { return; }\r\n\r\n      collisions.length = 0;\r\n      distanceMap.clear();\r\n      el.object3D.getWorldPosition(position);\r\n      el.object3D.getWorldScale(colliderScale);\r\n      colliderRadius = data.radius * scaleFactor(colliderScale);\r\n      // Update collision list.\r\n      this.els.forEach(intersect);\r\n\r\n      // Emit events and add collision states, in order of distance.\r\n      collisions\r\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\r\n        .forEach(this.handleHit);\r\n\r\n      // Remove collision state from other elements.\r\n      this.collisions\r\n        .filter((el) => !distanceMap.has(el))\r\n        .forEach(this.handleHitEnd);\r\n\r\n      // Store new collisions\r\n      copyArray(this.collisions, collisions);\r\n\r\n      // Bounding sphere collision detection\r\n      function intersect (el) {\r\n        let radius, mesh, distance, extent;\r\n\r\n        if (!el.isEntity) { return; }\r\n\r\n        mesh = el.getObject3D('mesh');\r\n\r\n        if (!mesh) { return; }\r\n\r\n        box.setFromObject(mesh).getSize(size);\r\n        extent = Math.max(size.x, size.y, size.z) / 2;\r\n        radius = Math.sqrt(2 * extent * extent);\r\n        box.getCenter(meshPosition);\r\n\r\n        if (!radius) { return; }\r\n\r\n        distance = position.distanceTo(meshPosition);\r\n        if (distance < radius + colliderRadius) {\r\n          collisions.push(el);\r\n          distanceMap.set(el, distance);\r\n        }\r\n      }\r\n      // use max of scale factors to maintain bounding sphere collision\r\n      function scaleFactor (scaleVec) {\r\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\r\n      }\r\n    };\r\n  })(),\r\n\r\n  handleHit: function (targetEl) {\r\n    targetEl.emit('hit');\r\n    targetEl.addState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hit', this.eventDetail);\r\n  },\r\n  handleHitEnd: function (targetEl) {\r\n    targetEl.emit('hitend');\r\n    targetEl.removeState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hitend', this.eventDetail);\r\n  }\r\n});\r\n\r\nfunction copyArray (dest, source) {\r\n  dest.length = 0;\r\n  for (let i = 0; i < source.length; i++) { dest[i] = source[i]; }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","require('./checkpoint');\r\nrequire('./cube-env-map');\r\nrequire('./grab');\r\nrequire('./normal-material');\r\nrequire('./sphere-collider');\r\n"],"names":[],"sourceRoot":""}