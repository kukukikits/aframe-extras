{"version":3,"file":"components/grab.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD,iCAAiC,mBAAmB;AACpD,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;UCzED;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://bs-aframe-extras/webpack/universalModuleDefinition","webpack://bs-aframe-extras/./src/misc/grab.js","webpack://bs-aframe-extras/webpack/bootstrap","webpack://bs-aframe-extras/webpack/before-startup","webpack://bs-aframe-extras/webpack/startup","webpack://bs-aframe-extras/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/* global CANNON */\r\n\r\n/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Handles events coming from the hand-controls.\r\n * Determines if the entity is grabbed or released.\r\n * Updates its position to move along the controller.\r\n */\r\nmodule.exports = AFRAME.registerComponent('grab', {\r\n  init: function () {\r\n    this.system = this.el.sceneEl.systems.physics;\r\n\r\n    this.GRABBED_STATE = 'grabbed';\r\n\r\n    this.grabbing = false;\r\n    this.hitEl =      /** @type {AFRAME.Element}    */ null;\r\n    this.physics =    /** @type {AFRAME.System}     */ this.el.sceneEl.systems.physics;\r\n    this.constraint = /** @type {CANNON.Constraint} */ null;\r\n\r\n    // Bind event handlers\r\n    this.onHit = this.onHit.bind(this);\r\n    this.onGripOpen = this.onGripOpen.bind(this);\r\n    this.onGripClose = this.onGripClose.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const el = this.el;\r\n    el.addEventListener('hit', this.onHit);\r\n    el.addEventListener('gripdown', this.onGripClose);\r\n    el.addEventListener('gripup', this.onGripOpen);\r\n    el.addEventListener('trackpaddown', this.onGripClose);\r\n    el.addEventListener('trackpadup', this.onGripOpen);\r\n    el.addEventListener('triggerdown', this.onGripClose);\r\n    el.addEventListener('triggerup', this.onGripOpen);\r\n  },\r\n\r\n  pause: function () {\r\n    const el = this.el;\r\n    el.removeEventListener('hit', this.onHit);\r\n    el.removeEventListener('gripdown', this.onGripClose);\r\n    el.removeEventListener('gripup', this.onGripOpen);\r\n    el.removeEventListener('trackpaddown', this.onGripClose);\r\n    el.removeEventListener('trackpadup', this.onGripOpen);\r\n    el.removeEventListener('triggerdown', this.onGripClose);\r\n    el.removeEventListener('triggerup', this.onGripOpen);\r\n  },\r\n\r\n  onGripClose: function () {\r\n    this.grabbing = true;\r\n  },\r\n\r\n  onGripOpen: function () {\r\n    const hitEl = this.hitEl;\r\n    this.grabbing = false;\r\n    if (!hitEl) { return; }\r\n    hitEl.removeState(this.GRABBED_STATE);\r\n    this.hitEl = undefined;\r\n    this.system.removeConstraint(this.constraint);\r\n    this.constraint = null;\r\n  },\r\n\r\n  onHit: function (evt) {\r\n    const hitEl = evt.detail.el;\r\n    // If the element is already grabbed (it could be grabbed by another controller).\r\n    // If the hand is not grabbing the element does not stick.\r\n    // If we're already grabbing something you can't grab again.\r\n    if (hitEl.is(this.GRABBED_STATE) || !this.grabbing || this.hitEl) { return; }\r\n    hitEl.addState(this.GRABBED_STATE);\r\n    this.hitEl = hitEl;\r\n    this.constraint = new CANNON.LockConstraint(this.el.body, hitEl.body);\r\n    this.system.addConstraint(this.constraint);\r\n  }\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/misc/grab.js\");\n",""],"names":[],"sourceRoot":""}