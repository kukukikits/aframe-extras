{"version":3,"file":"components/sphere-collider.min.js","mappings":"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","sources":["webpack://bs-aframe-extras/webpack/universalModuleDefinition","webpack://bs-aframe-extras/./src/misc/sphere-collider.js","webpack://bs-aframe-extras/webpack/bootstrap","webpack://bs-aframe-extras/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Implement bounding sphere collision detection for entities with a mesh.\r\n * Sets the specified state on the intersected entities.\r\n *\r\n * @property {string} objects - Selector of the entities to test for collision.\r\n * @property {string} state - State to set on collided entities.\r\n *\r\n */\r\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\r\n  schema: {\r\n    enabled: {default: true},\r\n    interval: {default: 80},\r\n    objects: {default: ''},\r\n    state: {default: 'collided'},\r\n    radius: {default: 0.05},\r\n    watch: {default: true}\r\n  },\r\n\r\n  init: function () {\r\n    /** @type {MutationObserver} */\r\n    this.observer = null;\r\n    /** @type {Array<Element>} Elements to watch for collisions. */\r\n    this.els = [];\r\n    /** @type {Array<Element>} Elements currently in collision state. */\r\n    this.collisions = [];\r\n    this.prevCheckTime = undefined;\r\n\r\n    this.eventDetail = {};\r\n    this.handleHit = this.handleHit.bind(this);\r\n    this.handleHitEnd = this.handleHitEnd.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const sceneEl = this.el.sceneEl;\r\n\r\n    if (this.data.watch) {\r\n      this.observer = new MutationObserver(this.update.bind(this, null));\r\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\r\n    }\r\n  },\r\n\r\n  pause: function () {\r\n    if (this.observer) {\r\n      this.observer.disconnect();\r\n      this.observer = null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update list of entities to test for collision.\r\n   */\r\n  update: function () {\r\n    const data = this.data;\r\n    let objectEls;\r\n\r\n    // Push entities into list of els to intersect.\r\n    if (data.objects) {\r\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\r\n    } else {\r\n      // If objects not defined, intersect with everything.\r\n      objectEls = this.el.sceneEl.children;\r\n    }\r\n    // Convert from NodeList to Array\r\n    this.els = Array.prototype.slice.call(objectEls);\r\n  },\r\n\r\n  tick: (function () {\r\n    const position = new THREE.Vector3(),\r\n        meshPosition = new THREE.Vector3(),\r\n        colliderScale = new THREE.Vector3(),\r\n        size = new THREE.Vector3(),\r\n        box = new THREE.Box3(),\r\n        collisions = [],\r\n        distanceMap = new Map();\r\n    return function (time) {\r\n      if (!this.data.enabled) { return; }\r\n\r\n      // Only check for intersection if interval time has passed.\r\n      const prevCheckTime = this.prevCheckTime;\r\n      if (prevCheckTime && (time - prevCheckTime < this.data.interval)) { return; }\r\n      // Update check time.\r\n      this.prevCheckTime = time;\r\n\r\n      const el = this.el,\r\n          data = this.data,\r\n          mesh = el.getObject3D('mesh');\r\n      let colliderRadius;\r\n\r\n      if (!mesh) { return; }\r\n\r\n      collisions.length = 0;\r\n      distanceMap.clear();\r\n      el.object3D.getWorldPosition(position);\r\n      el.object3D.getWorldScale(colliderScale);\r\n      colliderRadius = data.radius * scaleFactor(colliderScale);\r\n      // Update collision list.\r\n      this.els.forEach(intersect);\r\n\r\n      // Emit events and add collision states, in order of distance.\r\n      collisions\r\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\r\n        .forEach(this.handleHit);\r\n\r\n      // Remove collision state from other elements.\r\n      this.collisions\r\n        .filter((el) => !distanceMap.has(el))\r\n        .forEach(this.handleHitEnd);\r\n\r\n      // Store new collisions\r\n      copyArray(this.collisions, collisions);\r\n\r\n      // Bounding sphere collision detection\r\n      function intersect (el) {\r\n        let radius, mesh, distance, extent;\r\n\r\n        if (!el.isEntity) { return; }\r\n\r\n        mesh = el.getObject3D('mesh');\r\n\r\n        if (!mesh) { return; }\r\n\r\n        box.setFromObject(mesh).getSize(size);\r\n        extent = Math.max(size.x, size.y, size.z) / 2;\r\n        radius = Math.sqrt(2 * extent * extent);\r\n        box.getCenter(meshPosition);\r\n\r\n        if (!radius) { return; }\r\n\r\n        distance = position.distanceTo(meshPosition);\r\n        if (distance < radius + colliderRadius) {\r\n          collisions.push(el);\r\n          distanceMap.set(el, distance);\r\n        }\r\n      }\r\n      // use max of scale factors to maintain bounding sphere collision\r\n      function scaleFactor (scaleVec) {\r\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\r\n      }\r\n    };\r\n  })(),\r\n\r\n  handleHit: function (targetEl) {\r\n    targetEl.emit('hit');\r\n    targetEl.addState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hit', this.eventDetail);\r\n  },\r\n  handleHitEnd: function (targetEl) {\r\n    targetEl.emit('hitend');\r\n    targetEl.removeState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hitend', this.eventDetail);\r\n  }\r\n});\r\n\r\nfunction copyArray (dest, source) {\r\n  dest.length = 0;\r\n  for (let i = 0; i < source.length; i++) { dest[i] = source[i]; }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(109);\n"],"names":["root","factory","exports","module","define","amd","a","i","self","AFRAME","registerComponent","schema","enabled","default","interval","objects","state","radius","watch","init","this","observer","els","collisions","prevCheckTime","undefined","eventDetail","handleHit","bind","handleHitEnd","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","pause","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","time","colliderRadius","scaleVec","getObject3D","length","clear","object3D","getWorldPosition","getWorldScale","Math","max","x","y","z","forEach","mesh","distance","extent","isEntity","setFromObject","getSize","sqrt","getCenter","distanceTo","push","set","sort","b","get","filter","has","dest","source","copyArray","targetEl","emit","addState","removeState","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}