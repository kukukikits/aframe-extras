{"version":3,"file":"components/sphere-collider.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,eAAe,YAAY;AAC3B,cAAc,YAAY;AAC1B,YAAY,oBAAoB;AAChC,aAAa,cAAc;AAC3B,YAAY;AACZ,GAAG;AACH;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,mBAAmB,OAAO;AAC5C;;;;;;;UChKA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://bs-aframe-extras/webpack/universalModuleDefinition","webpack://bs-aframe-extras/./src/misc/sphere-collider.js","webpack://bs-aframe-extras/webpack/bootstrap","webpack://bs-aframe-extras/webpack/before-startup","webpack://bs-aframe-extras/webpack/startup","webpack://bs-aframe-extras/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Implement bounding sphere collision detection for entities with a mesh.\r\n * Sets the specified state on the intersected entities.\r\n *\r\n * @property {string} objects - Selector of the entities to test for collision.\r\n * @property {string} state - State to set on collided entities.\r\n *\r\n */\r\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\r\n  schema: {\r\n    enabled: {default: true},\r\n    interval: {default: 80},\r\n    objects: {default: ''},\r\n    state: {default: 'collided'},\r\n    radius: {default: 0.05},\r\n    watch: {default: true}\r\n  },\r\n\r\n  init: function () {\r\n    /** @type {MutationObserver} */\r\n    this.observer = null;\r\n    /** @type {Array<Element>} Elements to watch for collisions. */\r\n    this.els = [];\r\n    /** @type {Array<Element>} Elements currently in collision state. */\r\n    this.collisions = [];\r\n    this.prevCheckTime = undefined;\r\n\r\n    this.eventDetail = {};\r\n    this.handleHit = this.handleHit.bind(this);\r\n    this.handleHitEnd = this.handleHitEnd.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const sceneEl = this.el.sceneEl;\r\n\r\n    if (this.data.watch) {\r\n      this.observer = new MutationObserver(this.update.bind(this, null));\r\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\r\n    }\r\n  },\r\n\r\n  pause: function () {\r\n    if (this.observer) {\r\n      this.observer.disconnect();\r\n      this.observer = null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update list of entities to test for collision.\r\n   */\r\n  update: function () {\r\n    const data = this.data;\r\n    let objectEls;\r\n\r\n    // Push entities into list of els to intersect.\r\n    if (data.objects) {\r\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\r\n    } else {\r\n      // If objects not defined, intersect with everything.\r\n      objectEls = this.el.sceneEl.children;\r\n    }\r\n    // Convert from NodeList to Array\r\n    this.els = Array.prototype.slice.call(objectEls);\r\n  },\r\n\r\n  tick: (function () {\r\n    const position = new THREE.Vector3(),\r\n        meshPosition = new THREE.Vector3(),\r\n        colliderScale = new THREE.Vector3(),\r\n        size = new THREE.Vector3(),\r\n        box = new THREE.Box3(),\r\n        collisions = [],\r\n        distanceMap = new Map();\r\n    return function (time) {\r\n      if (!this.data.enabled) { return; }\r\n\r\n      // Only check for intersection if interval time has passed.\r\n      const prevCheckTime = this.prevCheckTime;\r\n      if (prevCheckTime && (time - prevCheckTime < this.data.interval)) { return; }\r\n      // Update check time.\r\n      this.prevCheckTime = time;\r\n\r\n      const el = this.el,\r\n          data = this.data,\r\n          mesh = el.getObject3D('mesh');\r\n      let colliderRadius;\r\n\r\n      if (!mesh) { return; }\r\n\r\n      collisions.length = 0;\r\n      distanceMap.clear();\r\n      el.object3D.getWorldPosition(position);\r\n      el.object3D.getWorldScale(colliderScale);\r\n      colliderRadius = data.radius * scaleFactor(colliderScale);\r\n      // Update collision list.\r\n      this.els.forEach(intersect);\r\n\r\n      // Emit events and add collision states, in order of distance.\r\n      collisions\r\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\r\n        .forEach(this.handleHit);\r\n\r\n      // Remove collision state from other elements.\r\n      this.collisions\r\n        .filter((el) => !distanceMap.has(el))\r\n        .forEach(this.handleHitEnd);\r\n\r\n      // Store new collisions\r\n      copyArray(this.collisions, collisions);\r\n\r\n      // Bounding sphere collision detection\r\n      function intersect (el) {\r\n        let radius, mesh, distance, extent;\r\n\r\n        if (!el.isEntity) { return; }\r\n\r\n        mesh = el.getObject3D('mesh');\r\n\r\n        if (!mesh) { return; }\r\n\r\n        box.setFromObject(mesh).getSize(size);\r\n        extent = Math.max(size.x, size.y, size.z) / 2;\r\n        radius = Math.sqrt(2 * extent * extent);\r\n        box.getCenter(meshPosition);\r\n\r\n        if (!radius) { return; }\r\n\r\n        distance = position.distanceTo(meshPosition);\r\n        if (distance < radius + colliderRadius) {\r\n          collisions.push(el);\r\n          distanceMap.set(el, distance);\r\n        }\r\n      }\r\n      // use max of scale factors to maintain bounding sphere collision\r\n      function scaleFactor (scaleVec) {\r\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\r\n      }\r\n    };\r\n  })(),\r\n\r\n  handleHit: function (targetEl) {\r\n    targetEl.emit('hit');\r\n    targetEl.addState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hit', this.eventDetail);\r\n  },\r\n  handleHitEnd: function (targetEl) {\r\n    targetEl.emit('hitend');\r\n    targetEl.removeState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hitend', this.eventDetail);\r\n  }\r\n});\r\n\r\nfunction copyArray (dest, source) {\r\n  dest.length = 0;\r\n  for (let i = 0; i < source.length; i++) { dest[i] = source[i]; }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/misc/sphere-collider.js\");\n",""],"names":[],"sourceRoot":""}