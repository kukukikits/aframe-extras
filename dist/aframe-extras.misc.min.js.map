{"version":3,"file":"aframe-extras.misc.min.js","mappings":"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","sources":["webpack://bs-aframe-extras/webpack/universalModuleDefinition","webpack://bs-aframe-extras/./src/misc/checkpoint.js","webpack://bs-aframe-extras/./src/misc/cube-env-map.js","webpack://bs-aframe-extras/./src/misc/grab.js","webpack://bs-aframe-extras/./src/misc/normal-material.js","webpack://bs-aframe-extras/./src/misc/sphere-collider.js","webpack://bs-aframe-extras/webpack/bootstrap","webpack://bs-aframe-extras/./src/misc/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","module.exports = AFRAME.registerComponent('checkpoint', {\r\n  schema: {\r\n    offset: {default: {x: 0, y: 0, z: 0}, type: 'vec3'}\r\n  },\r\n\r\n  init: function () {\r\n    this.active = false;\r\n    this.targetEl = null;\r\n    this.fire = this.fire.bind(this);\r\n    this.offset = new THREE.Vector3();\r\n  },\r\n\r\n  update: function () {\r\n    this.offset.copy(this.data.offset);\r\n  },\r\n\r\n  play: function () { this.el.addEventListener('click', this.fire); },\r\n  pause: function () { this.el.removeEventListener('click', this.fire); },\r\n  remove: function () { this.pause(); },\r\n\r\n  fire: function () {\r\n    const targetEl = this.el.sceneEl.querySelector('[checkpoint-controls]');\r\n    if (!targetEl) {\r\n      throw new Error('No `checkpoint-controls` component found.');\r\n    }\r\n    targetEl.components['checkpoint-controls'].setCheckpoint(this.el);\r\n  },\r\n\r\n  getOffset: function () {\r\n    return this.offset.copy(this.data.offset);\r\n  }\r\n});\r\n","/**\r\n * @param  {Array<THREE.Material>|THREE.Material} material\r\n * @return {Array<THREE.Material>}\r\n */\r\nfunction ensureMaterialArray (material) {\r\n  if (!material) {\r\n    return [];\r\n  } else if (Array.isArray(material)) {\r\n    return material;\r\n  } else if (material.materials) {\r\n    return material.materials;\r\n  } else {\r\n    return [material];\r\n  }\r\n}\r\n\r\n/**\r\n * @param  {THREE.Object3D} mesh\r\n * @param  {Array<string>} materialNames\r\n * @param  {THREE.Texture} envMap\r\n * @param  {number} reflectivity  [description]\r\n */\r\nfunction applyEnvMap (mesh, materialNames, envMap, reflectivity) {\r\n  if (!mesh) return;\r\n\r\n  materialNames = materialNames || [];\r\n\r\n  mesh.traverse((node) => {\r\n\r\n    if (!node.isMesh) return;\r\n\r\n    const meshMaterials = ensureMaterialArray(node.material);\r\n\r\n    meshMaterials.forEach((material) => {\r\n\r\n      if (material && !('envMap' in material)) return;\r\n      if (materialNames.length && materialNames.indexOf(material.name) === -1) return;\r\n\r\n      material.envMap = envMap;\r\n      material.reflectivity = reflectivity;\r\n      material.needsUpdate = true;\r\n\r\n    });\r\n\r\n  });\r\n}\r\n\r\n/**\r\n * Specifies an envMap on an entity, without replacing any existing material\r\n * properties.\r\n */\r\nmodule.exports = AFRAME.registerComponent('cube-env-map', {\r\n  multiple: true,\r\n\r\n  schema: {\r\n    path: {default: ''},\r\n    extension: {default: 'jpg', oneOf: ['jpg', 'png']},\r\n    enableBackground: {default: false},\r\n    reflectivity: {default: 1, min: 0, max: 1},\r\n    materials: {default: []}\r\n  },\r\n\r\n  init: function () {\r\n    const data = this.data;\r\n\r\n    this.texture = new THREE.CubeTextureLoader().load([\r\n      data.path + 'posx.' + data.extension, data.path + 'negx.' + data.extension,\r\n      data.path + 'posy.' + data.extension, data.path + 'negy.' + data.extension,\r\n      data.path + 'posz.' + data.extension, data.path + 'negz.' + data.extension\r\n    ]);\r\n    this.texture.format = THREE.RGBAFormat;\r\n\r\n    this.object3dsetHandler = () => {\r\n      const mesh = this.el.getObject3D('mesh');\r\n      const data = this.data;\r\n      applyEnvMap(mesh, data.materials, this.texture, data.reflectivity);\r\n    };\r\n\r\n    this.object3dsetHandler();\r\n    this.el.addEventListener('object3dset', this.object3dsetHandler);\r\n    \r\n  },\r\n\r\n  update: function (oldData) {\r\n    const data = this.data;\r\n    const mesh = this.el.getObject3D('mesh');\r\n\r\n    let addedMaterialNames = [];\r\n    let removedMaterialNames = [];\r\n\r\n    if (data.materials.length) {\r\n      if (oldData.materials) {\r\n        addedMaterialNames = data.materials.filter((name) => !oldData.materials.includes(name));\r\n        removedMaterialNames = oldData.materials.filter((name) => !data.materials.includes(name));\r\n      } else {\r\n        addedMaterialNames = data.materials;\r\n      }\r\n    }\r\n    if (addedMaterialNames.length) {\r\n      applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);\r\n    }\r\n    if (removedMaterialNames.length) {\r\n      applyEnvMap(mesh, removedMaterialNames, null, 1);\r\n    }\r\n\r\n    if (oldData.materials && data.reflectivity !== oldData.reflectivity) {\r\n      const maintainedMaterialNames = data.materials\r\n        .filter((name) => oldData.materials.includes(name));\r\n      if (maintainedMaterialNames.length) {\r\n        applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);\r\n      }\r\n    }\r\n\r\n    if (this.data.enableBackground && !oldData.enableBackground) {\r\n      this.setBackground(this.texture);\r\n    } else if (!this.data.enableBackground && oldData.enableBackground) {\r\n      this.setBackground(null);\r\n    }\r\n  },\r\n\r\n  remove: function () {\r\n    this.el.removeEventListener('object3dset', this.object3dsetHandler);\r\n    const mesh = this.el.getObject3D('mesh');\r\n    const data = this.data;\r\n\r\n    applyEnvMap(mesh, data.materials, null, 1);\r\n    if (data.enableBackground) this.setBackground(null);\r\n  },\r\n\r\n  setBackground: function (texture) {\r\n    this.el.sceneEl.object3D.background = texture;\r\n  }\r\n});","/* global CANNON */\r\n\r\n/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Handles events coming from the hand-controls.\r\n * Determines if the entity is grabbed or released.\r\n * Updates its position to move along the controller.\r\n */\r\nmodule.exports = AFRAME.registerComponent('grab', {\r\n  init: function () {\r\n    this.system = this.el.sceneEl.systems.physics;\r\n\r\n    this.GRABBED_STATE = 'grabbed';\r\n\r\n    this.grabbing = false;\r\n    this.hitEl =      /** @type {AFRAME.Element}    */ null;\r\n    this.physics =    /** @type {AFRAME.System}     */ this.el.sceneEl.systems.physics;\r\n    this.constraint = /** @type {CANNON.Constraint} */ null;\r\n\r\n    // Bind event handlers\r\n    this.onHit = this.onHit.bind(this);\r\n    this.onGripOpen = this.onGripOpen.bind(this);\r\n    this.onGripClose = this.onGripClose.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const el = this.el;\r\n    el.addEventListener('hit', this.onHit);\r\n    el.addEventListener('gripdown', this.onGripClose);\r\n    el.addEventListener('gripup', this.onGripOpen);\r\n    el.addEventListener('trackpaddown', this.onGripClose);\r\n    el.addEventListener('trackpadup', this.onGripOpen);\r\n    el.addEventListener('triggerdown', this.onGripClose);\r\n    el.addEventListener('triggerup', this.onGripOpen);\r\n  },\r\n\r\n  pause: function () {\r\n    const el = this.el;\r\n    el.removeEventListener('hit', this.onHit);\r\n    el.removeEventListener('gripdown', this.onGripClose);\r\n    el.removeEventListener('gripup', this.onGripOpen);\r\n    el.removeEventListener('trackpaddown', this.onGripClose);\r\n    el.removeEventListener('trackpadup', this.onGripOpen);\r\n    el.removeEventListener('triggerdown', this.onGripClose);\r\n    el.removeEventListener('triggerup', this.onGripOpen);\r\n  },\r\n\r\n  onGripClose: function () {\r\n    this.grabbing = true;\r\n  },\r\n\r\n  onGripOpen: function () {\r\n    const hitEl = this.hitEl;\r\n    this.grabbing = false;\r\n    if (!hitEl) { return; }\r\n    hitEl.removeState(this.GRABBED_STATE);\r\n    this.hitEl = undefined;\r\n    this.system.removeConstraint(this.constraint);\r\n    this.constraint = null;\r\n  },\r\n\r\n  onHit: function (evt) {\r\n    const hitEl = evt.detail.el;\r\n    // If the element is already grabbed (it could be grabbed by another controller).\r\n    // If the hand is not grabbing the element does not stick.\r\n    // If we're already grabbing something you can't grab again.\r\n    if (hitEl.is(this.GRABBED_STATE) || !this.grabbing || this.hitEl) { return; }\r\n    hitEl.addState(this.GRABBED_STATE);\r\n    this.hitEl = hitEl;\r\n    this.constraint = new CANNON.LockConstraint(this.el.body, hitEl.body);\r\n    this.system.addConstraint(this.constraint);\r\n  }\r\n});\r\n","/**\r\n * Recursively applies a MeshNormalMaterial to the entity, such that\r\n * face colors are determined by their orientation. Helpful for\r\n * debugging geometry\r\n */\r\nmodule.exports = AFRAME.registerComponent('normal-material', {\r\n  init: function () {\r\n    this.material = new THREE.MeshNormalMaterial({flatShading: true});\r\n    this.applyMaterial = this.applyMaterial.bind(this);\r\n    this.el.addEventListener('object3dset', this.applyMaterial);\r\n    this.applyMaterial();\r\n  },\r\n\r\n  remove: function () {\r\n    this.el.removeEventListener('object3dset', this.applyMaterial);\r\n  },\r\n\r\n  applyMaterial: function () {\r\n    this.el.object3D.traverse((node) => {\r\n      if (node.isMesh) node.material = this.material;\r\n    });\r\n  }\r\n});\r\n","/**\r\n * Based on aframe/examples/showcase/tracked-controls.\r\n *\r\n * Implement bounding sphere collision detection for entities with a mesh.\r\n * Sets the specified state on the intersected entities.\r\n *\r\n * @property {string} objects - Selector of the entities to test for collision.\r\n * @property {string} state - State to set on collided entities.\r\n *\r\n */\r\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\r\n  schema: {\r\n    enabled: {default: true},\r\n    interval: {default: 80},\r\n    objects: {default: ''},\r\n    state: {default: 'collided'},\r\n    radius: {default: 0.05},\r\n    watch: {default: true}\r\n  },\r\n\r\n  init: function () {\r\n    /** @type {MutationObserver} */\r\n    this.observer = null;\r\n    /** @type {Array<Element>} Elements to watch for collisions. */\r\n    this.els = [];\r\n    /** @type {Array<Element>} Elements currently in collision state. */\r\n    this.collisions = [];\r\n    this.prevCheckTime = undefined;\r\n\r\n    this.eventDetail = {};\r\n    this.handleHit = this.handleHit.bind(this);\r\n    this.handleHitEnd = this.handleHitEnd.bind(this);\r\n  },\r\n\r\n  play: function () {\r\n    const sceneEl = this.el.sceneEl;\r\n\r\n    if (this.data.watch) {\r\n      this.observer = new MutationObserver(this.update.bind(this, null));\r\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\r\n    }\r\n  },\r\n\r\n  pause: function () {\r\n    if (this.observer) {\r\n      this.observer.disconnect();\r\n      this.observer = null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update list of entities to test for collision.\r\n   */\r\n  update: function () {\r\n    const data = this.data;\r\n    let objectEls;\r\n\r\n    // Push entities into list of els to intersect.\r\n    if (data.objects) {\r\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\r\n    } else {\r\n      // If objects not defined, intersect with everything.\r\n      objectEls = this.el.sceneEl.children;\r\n    }\r\n    // Convert from NodeList to Array\r\n    this.els = Array.prototype.slice.call(objectEls);\r\n  },\r\n\r\n  tick: (function () {\r\n    const position = new THREE.Vector3(),\r\n        meshPosition = new THREE.Vector3(),\r\n        colliderScale = new THREE.Vector3(),\r\n        size = new THREE.Vector3(),\r\n        box = new THREE.Box3(),\r\n        collisions = [],\r\n        distanceMap = new Map();\r\n    return function (time) {\r\n      if (!this.data.enabled) { return; }\r\n\r\n      // Only check for intersection if interval time has passed.\r\n      const prevCheckTime = this.prevCheckTime;\r\n      if (prevCheckTime && (time - prevCheckTime < this.data.interval)) { return; }\r\n      // Update check time.\r\n      this.prevCheckTime = time;\r\n\r\n      const el = this.el,\r\n          data = this.data,\r\n          mesh = el.getObject3D('mesh');\r\n      let colliderRadius;\r\n\r\n      if (!mesh) { return; }\r\n\r\n      collisions.length = 0;\r\n      distanceMap.clear();\r\n      el.object3D.getWorldPosition(position);\r\n      el.object3D.getWorldScale(colliderScale);\r\n      colliderRadius = data.radius * scaleFactor(colliderScale);\r\n      // Update collision list.\r\n      this.els.forEach(intersect);\r\n\r\n      // Emit events and add collision states, in order of distance.\r\n      collisions\r\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\r\n        .forEach(this.handleHit);\r\n\r\n      // Remove collision state from other elements.\r\n      this.collisions\r\n        .filter((el) => !distanceMap.has(el))\r\n        .forEach(this.handleHitEnd);\r\n\r\n      // Store new collisions\r\n      copyArray(this.collisions, collisions);\r\n\r\n      // Bounding sphere collision detection\r\n      function intersect (el) {\r\n        let radius, mesh, distance, extent;\r\n\r\n        if (!el.isEntity) { return; }\r\n\r\n        mesh = el.getObject3D('mesh');\r\n\r\n        if (!mesh) { return; }\r\n\r\n        box.setFromObject(mesh).getSize(size);\r\n        extent = Math.max(size.x, size.y, size.z) / 2;\r\n        radius = Math.sqrt(2 * extent * extent);\r\n        box.getCenter(meshPosition);\r\n\r\n        if (!radius) { return; }\r\n\r\n        distance = position.distanceTo(meshPosition);\r\n        if (distance < radius + colliderRadius) {\r\n          collisions.push(el);\r\n          distanceMap.set(el, distance);\r\n        }\r\n      }\r\n      // use max of scale factors to maintain bounding sphere collision\r\n      function scaleFactor (scaleVec) {\r\n        return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);\r\n      }\r\n    };\r\n  })(),\r\n\r\n  handleHit: function (targetEl) {\r\n    targetEl.emit('hit');\r\n    targetEl.addState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hit', this.eventDetail);\r\n  },\r\n  handleHitEnd: function (targetEl) {\r\n    targetEl.emit('hitend');\r\n    targetEl.removeState(this.data.state);\r\n    this.eventDetail.el = targetEl;\r\n    this.el.emit('hitend', this.eventDetail);\r\n  }\r\n});\r\n\r\nfunction copyArray (dest, source) {\r\n  dest.length = 0;\r\n  for (let i = 0; i < source.length; i++) { dest[i] = source[i]; }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","require('./checkpoint');\r\nrequire('./cube-env-map');\r\nrequire('./grab');\r\nrequire('./normal-material');\r\nrequire('./sphere-collider');\r\n"],"names":["root","factory","exports","module","define","amd","a","i","self","AFRAME","registerComponent","schema","offset","default","x","y","z","type","init","this","active","targetEl","fire","bind","THREE","Vector3","update","copy","data","play","el","addEventListener","pause","removeEventListener","remove","sceneEl","querySelector","Error","components","setCheckpoint","getOffset","applyEnvMap","mesh","materialNames","envMap","reflectivity","traverse","node","material","isMesh","Array","isArray","materials","forEach","length","indexOf","name","needsUpdate","multiple","path","extension","oneOf","enableBackground","min","max","texture","CubeTextureLoader","load","format","RGBAFormat","object3dsetHandler","getObject3D","oldData","addedMaterialNames","removedMaterialNames","filter","includes","maintainedMaterialNames","setBackground","object3D","background","system","systems","physics","GRABBED_STATE","grabbing","hitEl","constraint","onHit","onGripOpen","onGripClose","removeState","undefined","removeConstraint","evt","detail","is","addState","CANNON","LockConstraint","body","addConstraint","MeshNormalMaterial","flatShading","applyMaterial","enabled","interval","objects","state","radius","watch","observer","els","collisions","prevCheckTime","eventDetail","handleHit","handleHitEnd","MutationObserver","observe","childList","subtree","disconnect","objectEls","querySelectorAll","children","prototype","slice","call","tick","position","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","time","colliderRadius","scaleVec","clear","getWorldPosition","getWorldScale","Math","distance","extent","isEntity","setFromObject","getSize","sqrt","getCenter","distanceTo","push","set","sort","b","get","has","dest","source","copyArray","emit","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}